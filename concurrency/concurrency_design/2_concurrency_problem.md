# 并发可能出现的问题

2023-06-13
***
## 简介

线程之间主要通过共享对字段和引用的访问进行通信。这种通信方式十分有效，但是可能导致两种错误：

- 线程干扰（thread interference）
- 内存不一致（memory consistency errors）

而避免这两种错误的方法就是同步。

但是同步又会导致线程争用，当两个或多个线程尝试访问相同资源时会出现该问题，使得某些线程运行缓慢，甚至挂起执行。

如饥饿（starvation）和活锁（livelock）就是线程争用导致的问题。

## 线程干扰和数据争用

两个或多个线程在临界区外修改共享变量值（即不采用同步机制修改共享变量），导致 **数据争用 (data race)** 或**竞争条件**（race condition）。

此时，程序执行的最终结果依赖于线程执行的顺序。例如：

```java
public class Account {
	private float balance;
	
	public void modify (float difference) {
		float value=this.balance;
		this.balance=value+difference;
	}
}
```

假设有两个不同线程在同一个 `Account` 对象上执行 `modify()` 方法。根据执行顺序不同，最终结果可能不同。设 `balance` 初始值为 1000，两个线程调用 `modify()` 的参数也都是 1000，那么期望的最终结果应该是 3000。

但是，如果两个任务同时执行第一个句子，然后同时执行第二个句子，最终结果为 2000。这是因为 `modify() `不是原子操作，`Account` 类不是线程安全的。

这只是一种操作重叠的情形，只要是非原子操作，都可能导致该问题。这种操作的结果不可预测，很难发现。

```ad-note
当不同线程作用于相同数据的操作出现交叉，就发生线程干扰。即线程对数据的一个操作包含多个步骤，步骤之间出现重叠，导致数据争用。
```

## 内存不一致

不同线程查看相同数据获得不同结果的情况，称为内存不一致（Memory Consistency Errors）。内存不一致的原因很复杂，这里不予讨论。我们只看如何避免该情况的发生。

避免内存不一致的关键是理解操作的先后关系，保证一个线程写入数据对另一个线程是可见的。

假设我们初始化了一个 `int` 字段：

```java
int counter = 0;
```

该字段由两个线程 A 和 B 共享。假设线程 A 增加 `counter` 的值：

```java
counter++;
```

随后，线程 B 输出 `counter`:

```java
System.out.println(counter);
```

如果两个语句在同一个线程中执行，毫无疑问输出结果为 "1"。而在两个线程中，输出可能是 "0"，因为不能保证线程 A 对 `counter` 的修改对 B 是可见的，除非采用措施保证两个语句发生的先后关系。

创建 happens-before 关系的方式有多种，其中一个就是同步。

## 死锁

两个或多个线程互相等待共享资源，如 A 等待 B 持有的资源，B 等待 A 持有的资源，一直阻塞称之为**死锁**（deadlock）。当以下四种情况（Coffman's conditions）同时出现，就出现死锁:

- 互斥(mutual exclusion)：死锁中涉及的资源是非共享的，一次只能有一个线程获取该资源。
- 持有并等待(hold and wait condition)：一个线程持有一个资源的互斥锁，并且需要另一个资源的互斥锁。该线程等待时，不释放资源。
- 非抢占式(No pre-emption)：只能由持有资源的线程释放该资源。
- 循环等待(Circular wait)：线程 1 需要线程 2 持有的资源，线程 2 需要线程 3 持有的资源…线程 n 需要线程 1 持有的资源。

避免死锁的方式：

- 忽略：这是最常用的方法。如果出现死锁，程序终止，重新运行。
- 检测：使用一个专门的线程检查系统状态是否发生死锁。如果检查到死锁，采取对应措施，如停止其中一个任务，或强制释放资源。
- 预防：防止 Coffman 条件中的一个或多个出现。
- 避免：如果在任务执行前知道要使用的资源，就可以避免死锁。在线程执行前，分析系统空闲的资源以及线程执行所需的资源，以决定是否开始执行。

## 活锁

当两个线程总是因为对方状态的改变而改变，导致它们处于状态更新循环，无法继续执行，称为**活锁**（livelock）。

例如，两个任务 Task 1 和 Task 2，都需要两个资源 Resource 1 和 Resource 2。假设 Task 1 持有 Resource 1 的互斥锁，Task 2 持有 Resource 2 的互斥锁，两个任务都无法获得对方资源，它们释放资源重新循环，即 Task 1 释放 Resource 1 锁定 Resource 2，Task 2 释放 Resource 2 锁定 Resource 1，这种情况可以无限循环下去，因此任务永远不会结束。

## 资源饥饿

当一个任务永远无法获得对共享资源的访问而暂停运行，称之为**资源饥饿** （Resource starvation）。

当多个任务同时等待一个资源，系统需要选择一个任务获得该资源并执行。如果系统选择任务的算法不好，会导致线程长时间等待。

**公平**是解决该问题的方法。所有的任务都有机会持有资源。例如，在实现算法时，挑选下一个持有资源的任务时考虑任务已经等待的时间。不过，公平实现算法本身也有开销，可能会降低程序的吞吐量。

## 优先级反转

**优先级反转**(priority inversion)，当低优先级任务持有高优先级任务所需的资源，就发生优先级反转，此时低优先级任务比高优先级任务先执行完。
