# 并发算法设计

2023-06-13
****
## 简介

五步获得串行算法的并行版本：

1. 分析（找到可并行部分）
2. 设计（分解）
3. 实现
4. 正确性验证
5. 效率验证

实现并行算法的起点是它的串行版本。虽然我们可以一开始就设计并行算法，不过串行算法至少有两个好处：

1. 可以使用串行算法的结果验证并行算法的正确行，从而辅助验证并行算法中是否存在数据争用或类似的问题。
2. 分析两种算法的吞吐量，查看并行是否确实改善了响应时间和吞吐量。

## 第一步：分析

这一步分析算法的串行版本，查找其中可以并发执行的代码块。重点关注执行时间长和代码量大的部分，一般将这些部分改为并行版本能获得更大的性能提升。

常见的适合并行的代码块包括：步骤之间互相独立的循环，不依赖于其它代码的代码段，例如应用的初始化步骤中，连接数据库、加载配置文件、初始化一些对象等都是相互独立的任务。

## 第二步：设计

在明确并行化哪些代码后，需要确定如何并行。更改的代码主要影响两部分：

- 代码结构
- 数据结构组织

可以采用两种方式实现该任务：

- 分解任务（Task decomposition），将代码拆分为两个或多个可以并行执行的独立任务。对需要按顺序执行的任务，使用同步机制。
- 分解数据（Data decomposition），同一线程的多个实例对数据集的子集执行。数据集为共享资源，如果线程需要修改数据，必须通过临界区来保护对其的访问。

另一个需要注意的是并行的粒度。实现算法的并行版本是为了提高性能，因此应该使用所有可用的处理器或内核。另外，使用同步机制会引入一些需要执行的额外指令。如果将算法拆分为很多细小的任务（细粒度），则同步引入的额外指令可能会导致性能下降。如果拆分的任务数小于内核数（粗粒度），则无法充分利用 CPU资源。还必须考虑每个线程要完成的工作，尤其是细粒度的情况，应用执行的总时长由所需时间最长的任务决定，因此必须把握一个平衡。

## 第三步：实现

使用编程语言实现并发算法，在必要的情况下使用一个多线程库。Java 有专门的并发支持库。

## 第四步：测试

算法实现后，还需要测试。如果有对应的串行版本，可对比两种算法的结果，以验证并行算法是否正确。

并行算法的测试和调试很困难，因为无法保证程序不同任务的执行顺序。

## 第五步：调参

最后一步是对比并行算法和串行算法的吞吐量。如果结果和预期不一致，则需要检查算法，找到导致并行性能不佳的原因。

还可以测试算法的不同参数（如粒度或任务数），以找到最佳配置。

衡量并行算法性能提升的指标有多种。其中有三个最流行：

- **加速比**（Speedup），用于对比并行和串行算法相对性能的指标

$$Speedup=\frac{T_{sequential}}{T_{concurrent}}$$

这里，$T_{sequential}$ 是串行算法的执行时间，$T_{concurrent}$ 是并行算法的执行时间。

- **Amdahl's law**，用于计算串行算法并行化预期的最大提升

$$Speedup\leq\frac{1}{(1-P)+\frac{P}{N}}$$

这里，$P$ 是可并行化代码的比例，$N$ 是用于执行算法的内核数。

例如，如果可以并行化 75% 的代码，有四个内核，则最大加速比为

$$Speedup\leq\frac{1}{(1-0.75)+(\frac{0.75}{4})}\leq\frac{1}{0.44}\leq2.29$$

- **Gustafson-Barsis' law**，Amdahl's law 的局限性在于没有考虑输入问题，Gustafson law 表示在内核多时，可以解决数据规模更大的问题，公式如下：

$$Speedup=N-(1-P)*(N-1)$$

这里，N是内核数，P 是并行化代码比例，和上面同样的例子：

$$Speedup=4-0.25*3=3.25$$

## 总结

首先，并不是所有算法都适合并行化。例如，执行一个循环，而当前步骤的迭代结果依赖于上一次迭代的结果，这种循环就不能并行化；同理，递归算法也不能并行化。

其次，性能已经很好的串行算法没必要并行化。

最后，在实现并行应用时，需要考虑以下几点：

- 效率：并行算法相对串行算法应当效率更高。
- 简洁：实现算法，不管并行与否，都应该尽可能地简单。使其更容易实现、测试和维护，这样错误也更少。
- 可移植性：并行算法在不同平台上执行改变应当尽可能小。对 Java 这不是问题。
- 可扩展性：如可以使用任意数目的内核。
