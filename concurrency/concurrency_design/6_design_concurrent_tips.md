# 设计并发算法的技巧

2023-06-14
***
## 正确识别独立的 task

只能相互独立的 task 才能并发执行。对有顺序依赖的多个 task，没有并发的价值。但是，如果一个 task 有许多初始化步骤，这些初始化步骤相互独立，此时可以并发执行这些初始化步骤，然后使用同步类来控制 task 的执行。

另一个不能使用并发的情况是，有一个循环，循环的下一步依赖于前一步生成的数据。

## 尽可能使用 high-level API 实现并发

Java 并发 API 提供了丰富的线程 API。你可以使用 Thread 或 Lock 控制线程的创建和同步，也可以使用高级并发对象，如 executor 或 fork/join 框架执行 tasks。这种 high-level API 具有以下好处：

- 不用担心线程的创建和管理。只需要创建 task，将其发送给 executor。
- high-level API 经过了优化，比直接使用线程性能好。例如，使用线程池可以避免反复创建线程的开销。
- 它们包含许多高级功能。例如，executor 支持以 `Future` 对象形式返回结果。
- 使用 high-level API 具有更好的可移植性
- 你的程序在未来的 Java 版本中可能更快。Java 开发人员在不断优化内部机制，JVM 优化对 JDK API 效果更好。

总而言之，处于性能和开发时间考虑，在实现并发算法之前，请优先考虑高级 API。

## 考虑可扩展性

实现并发算法的主要目标之一是充分利用计算机的资源，特别是处理器数。但是不同计算机的内核数不同，硬件也在不断发展。

因此，在设计并发算法时，不要预设处理器格式，而是动态获取系统信息，例如通过 `Runtime.getRuntime().availableProcessors()` 获得处理器数，然后根据处理器数计算合理的 task 数。这个过程会有一点开销，但使得算法的可扩展性更好，是值得的。

## 使用 thread-safe API

在并发应用开发中，应了解使用的类是否线程安全。对非 thread-safe 情况，有两个选择：

- 如果有 thread-safe 替代方案，那么使用它
- 如果没有 thread-safe 替代方案，则添加必要的同步以避免出问题

例如，在并发应用中需要一个 `List`，如果要从多个线程更新它，那么就不能使用 ArrayList，因为它不是 thread-safe 的。此时，可以使用 thread-safe 的替代方案，如 `ConcurrentLinkedDeque`, `CopyOnWriteArrayList` 或 `LinkedBlockingDeque`。

## 不要假定执行顺序

在并发应用中执行 task，如果没有使用同步机制，那么执行顺序是不确定的。task 的执行顺序和执行时间由操作系统的调度器决定。

如果你的算法依赖于 tasks 的执行顺序，在没有同步机制保护的前提下，会出现数据争用的情况，最终结果可能对，可能不对。检测数据争用非常难，因此一定要避免这种情况。

## 优先 local thread 变量

线程局部变量是一种特殊的变量。每个 task 对这个变量都有一个独立的值，因此不需要使用同步机制来保护对这个变量的访问。

这听起来有点奇怪。每个对象都有自己类的属性 copy，为什么需要线程局部变量？

考虑如下情况，你创建了一个 `Runnable` task，并希望执行该 task 的多个实例。你可以为每个线程创建一个 Runnable，也可以只创建一个 Runnable，然后使用它创建所有线程。对后者，所有线程访问类属性的同一个 copy，除非你使用 ThreadLocal 类。ThreadLocal 类不需要 Lock, Semaphore 或其它类似的类，就能保证每个线程都可以访问自己的变量实例。

另一个可以利用线程局部变量的情况是使用静态属性。类的所有实例共享静态属性，但是用 ThreadLocal 类声明例外。此时，每个线程访问独立 copy。

## 使用最简单的并行版本

建议以串行算法作为实现并发算法的起点，因为：

- 可以很容易地测试并行算法的正确性
- 可以衡量使用并发带来的性能增益

但不是每个算法都可以并行。解决问题的方法不止一种，你应该找容易并行的版本，并行化后同性能最好的串行版本比较。

## 尽量使用 immutable 对象

在并发应用中一个主要问题是数据争用。当两个或多个 tasks 可以修改存储在共享变量中的数据，并且访问该变量的操作没有临界区保护，就会发生这种情况。

有一种特殊的对象，称为不可变对象（immutable）。其主要特点是初始化后不能修改。如果想修改某个属性，只能创建新的对象。Java 中的 `String`  就是个很好的例子。

在并发应用中使用 immutable 对象有两个非常重要的优点：

- 不需要使用同步机制来保护它们。如果两个 tasks 要修改同一个 immutable 对象，它们会创建新的对象，因此两个 tasks 同时修改一个 immutable 对象的情况不会发生
- 不会遇到数据不一致的问题

Immutable 对象一个主要缺点是可能创建太多对象从而影响吞吐量、占用内存。对没有内部数据结构的简单对象，这通常不是问题，对包含其它对象集合的复杂对象，则可能导致严重的性能问题。

## 通过锁排序避免死锁

在并发应用中，避免死锁的最佳机制之一是强制 tasks 始终以相同顺序获取共享资源。一种简单的方法是为每个资源分配一个数字，当一个 task 需要多个资源，它必须按顺序请求。

例如，如果有两个 tasks，T1 和 T2，两者都需要资源 R1 和 R2，你可以强制它们都先请求 R1，再请求 R2。这样就不会出现死锁。

如果 T1 先请求 R1、再请求 R2，T2 则先请求 R2、再请求 R1，就出现死锁。例如，你有两个 tasks 需要获取两个 Lock 对象。然而它们请求 Lock 的顺序不同：

```java
public void operation1() {
	lock1.lock();
	lock2.lock();
.
}
public void operation2() {
	lock2.lock();
	lock1.lock();
}
```

有可能 operation1() 执行第一个句子时，operation2() 也执行它的第一个句子，它们都等待另一个锁，于是出现死锁。

只需要以相同顺序获取锁就能避开该问题。例如，改变 operation2 获取锁的顺序：

```java
public void operation2() {
	lock1.lock();
	lock2.lock();
}
```

## 使用原子变量替代同步

当你需要在多个 tasks 之间共享数据时，需要使用同步机制保护对该数据的访问，避免出现数据不一致的问题。

#volatile
在某些情况下可以用 `volatile` 关键字而不使用同步机制。如果只有一个 task 修改数据，而其它 tasks 读取数据，就可以使用 volatile，不会出现同步或数据不一致的问题。在其它场景，则需要使用 lock、synchronized 或其它同步方法。

在 Java 5，引入了一种新的变量——原子变量。原子变量支持对单个变量进行原子操作的类。这个解决方案是无锁的，即不需要使用锁或其它同步机制，因此性能比同步方案好。

主要原子变量类型：

- AtomicInteger
- AtomicLong
- AtomicReference
- AtomicBoolean
- LongAdder
- DoubleAdder

## 持锁时间要短

与其它同步机制一样，锁定义了一个临界区，在临界区一次只能执行一个 task。当一个 task 在临界区执行，其它需要进入临界区的 tasks 被阻塞。

应该特别注意临界区的代码，因为一不小心可能降低性能。临界区要尽可能小，并且应该只包含需要与其它 tasks 共享数据的指令。

要避免在临界区执行你无法控制的代码。例如，你正在编写一个库，它接受一个用户定义的 Callable 对象，根据需要启动它。你根本无法控制 Callable 内部会执行什么内容，它可能阻塞 I/O，请求锁，调用库中的其它方法，或者需要执行很长时间。因此，应该尽可能在你没有持有锁时执行它。如果无法实现，应该在文档中说明，并指出对 Callable 的限制，如不应该使用任何锁。`ConcurrentHashMap` 的 `compute()` 就是此类文档的很好例子。

## 在临界区避免阻塞操作

阻塞操作会暂停调用它们的 tasks。例如，读取文件或向控制台写入数据，调用这些操作的 tasks 需要等它们完成。

如果在临界区包含这些操作，所有需要执行临界区代码的 tasks 都会阻塞，从而降低性能。因此，除非必要，否则不要在临界区包含阻塞操作。

