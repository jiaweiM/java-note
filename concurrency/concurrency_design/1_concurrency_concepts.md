# 并发的基本概念

2023-06-14
***
## 并发和并行

并发（concurrency）和并行（parallelism）的概念十分相似。一般认为：

- 单核处理器上运行多个任务称为**并发**，操作系统通过任务调度器快速切换任务，使得所有任务看起来像在同时运行。
- **并行**指多个任务在不同电脑、处理器或单处理器的多核上同时运行。

从执行任务角度解释：

- **并发**表示如何处理多任务：可以一次处理一个任务（sequentially），也可以同时处理多个任务（concurrently）。例如，对单 CPU，多个任务切换运行，在一个任务结束前，无法处理下一个任务。
- **并行**表示如何处理单个任务：可以从头到尾将一个任务处理完，也可以将任务分成多个子任务，然后同时处理。

```ad-tip
多线程不是为了提高程序的运行效率，而是通过提高资源利用率来提高系统的效率。要提高程序效率，把语言写得接近机器语言，如使用汇编语言显然最快。
```

## 同步

在并发中，**同步**（synchronization）指协调两个或多个任务以获得所需结果。同步有两种类型：

- 控制同步（Control synchronization）：例如，如果 task2 依赖于 task1 的执行结果，那么 task2 就不能在 task1 完成前启动。
- 数据访问同步（Data access synchronization）：两个或多个任务都能访问一个共享变量，但在任何时刻只能有一个任务访问该变量。

**临界区**（critical section）和同步密不可分。临界区是一段访问共享资源的代码，不能被多个线程同时执行。

同步可用于避免并发任务中可能出现的一些错误，但会给算法带来额外开销。所以应当仔细考虑并行算法，将可以独立执行不需要在并行算法中交互的内容提出来，即控制好并发算法的**粒度**（granularity）：

- 粗粒度（大任务，低任务间通信），同步带来的开销低，但是无法充分利用 CPU；
- 细粒度（小任务，高任务间通信），同步带来的开销会很高，并且算法的吞吐量可能会不好。


实现同步的机制有多种，从理论上来讲，主要分为两类：

- 信号量（Semaphore），信号量是一种控制资源访问的机制。它包含一个保存可访问资源数目的变量，以及用来管理变量值的两个原子操作。互斥锁（mutex, mutual exclusion 的缩写）是一种特殊的信号量，它只有两个值（**资源空闲**，**资源占用**），只有将资源设置为 “资源占用” 的进程才能释放它。互斥锁可以通过保护临界区来避免数据争用。
- 监视器（Monitor），监视器是一种共享资源互斥的机制。它包含一个互斥锁（mutex），一个条件变量和两个操作（等待条件和发出条件信号）。发出条件信号后，等待它的任务之一接收到信号，继续执行。

另外，**线程安全**也和同步相关。如果使用共享数据的所有任务都受同步机制的保护，则称对应的代码段是线程安全的。

## Immutable 对象

不可变对象（immutable）在初始化后不能修改其可见状态（属性值），如果想修改不可变对象的值，只能重新创建一个。

Immutable 对象的最大优点是线程安全，在并发应用中可以随意使用，不会出现任何问题。

Java 中的 `String` 就是一个 Immutable 对象，当你给 `String` 对象重新分配值时，实际上创建了一个新的字符串。


## 原子性

不能被其它线程打断的操作称为**原子操作**（atomic operation）。

Java 中唯一的原子操作是赋值，如 `a=5`，但 `a=b++` 不是原子操作。为了实现同步，有时候需要使特定操作变为原子操作，在并发应用中，可以使用同步机制通过临界区实现原子操作。

原子是世界上的最小单位，原子性由此而来，即具有不可分割性（至少从化学角度是不可分割的）。比如 `a=0`（a 非 long 和 double 类型），这个操作不可分割，所以称为原子操作；再比如 `a++`，这个操作实际是 `a=a+1`，是可分割的，所以不是原子操作。

**原子变量**（atomic variable）指设置和获取该变量值的操作为原子操作的变量。使用同步机制可以实现原子变量，也可以用 CAS 这种无需同步的无锁方式实现原子变量。

非原子操作存在线程安全问题，需要使用同步技术将它变成一个原子操作。如果一个操作是原子操作，就称它具有**原子性**。java 的 concurrent 包下提供了一些原子类，如 `AtomicInteger`、`AtomicLong`、`AtomicReference` 等，这些类对特定类型的操作进行了包装，使其具有原子性。


## 共享变量

共享变量指多个线程都可以操作的变量。

在 JVM 中，Java 堆和方法区是多线程共享的数据区域，即保存在堆和方法区中的变量就是 Java 中的共享变量。

- 类变量保存在方法区
- 成员变量在堆内存
- 局部变量在栈内存

所以，类变量和成员变量都属于共享变量，而局部变量是非共享变量。

## 共享内存和信息传递

任务之间通信有两种方法:

- **共享内存**，当任务在同一台计算机上运行时使用。不同任务在相同的内存区读写，为了避免问题，对共享内存的访问必须位于临界区。
- **信息传递**，当任务在不同计算机上运行时使用。当 task1 需要和 task2 通信，它会按照预定义协议发送消息，如果 task1 在等待回复时阻塞，就是**同步通信**；如果 task1 在发送消息后继续执行，就是**异步通信**。

## 可见性

一个线程对进程中共享数据进行修改，该修改是否对另一个线程可见的问题，称为可见性问题（Visibility）。


## 进程和线程

在并发编程中，有两个基本执行单元：进程（process）和线程（thread）。在 Java 语言中，并发编程主要和线程相关。

一个电脑系统一般包括多个活动的进程和线程。即使是单核处理器也是如此，虽然任意时刻正在执行的线程只有一个。操作系统通过时间切片的方式，在进程和线程间共享单个处理器的处理时间。

在多任务处理系统中，CPU需要处理所有程序的操作，当用户来回切换它们时，需要记录这些程序执行到哪里。在操作系统中，CPU 切换到另一个进程，需要先保存当前进程的状态，然后恢复另一个进程的状态，当前运行任务转为就绪（或者挂起、删除）状态，另一个被选定的就绪任务成为当前任务。**上下文切换**就是这样一个过程，它允许CPU记录并恢复各种正在运行程序的状态，使它能够完成切换操作。

```ad-note
在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。在程序中，上下文切换保存在进程控制块（PCB）中，PCB还经常被称为“切换帧”。
```

对操作系统来说，一个任务就是一个进程，而在多个进程之间切换的时候，需要进行上下文切换，上下文切换比较耗费资源。于是人们考虑，能不能在一个进程中增加一些子任务，这样减少上下文切换的成本。比如我们使用 Word 时，可以同时进行打字、拼写检查、字数统计等，这些子任务之间共同使用同一个进程资源，因为它们之间的切换不需要进行上下文切换。

在同一进程内部，要同时干多件事，就需要同时运行多个子任务，我们把进程内的这些子任务称为**线程**（Thread）。

总的来说，可以把进程看作资源分配的基本单元，线程看作执行任务的基本单元，同一个进程内的线程共享资源。

对 Java 来说，一个JVM就是一个进程，而在JVM中，可以创建很多线程，多个线程之间共享JVM资源。

### 进程

进程，是一个计算机程序的运行实例，对 Java 来说，就是一个JVM 实例。它包含需要执行的指令，有自己独立的地址空间，包含完整的程序内容和数据。不同进程的地址空间相互隔离；进程拥有各种资源和状态信息，如打开的文件、子进程和信号处理等。

一般认为进程等效于程序或应用，然而实际上，一个程序可能包含许多互相合作的进程。为使不同进程间可交换资源，大多数操作系统支持进程间交流（Inter Process Communication, IPC）以交换资源。IPC 不仅支持相同系统进程间交流，还支持不同系统的进程间交流。

大多数 JVM 实现以单个进程运行，在 Java 中可以通过 `ProcessBuilder` 创建新的进程。

### 线程

线程也被称为轻量级进程。进行和线程都提供了一个执行环节，但是创建新的线程相对创建新的进程，需要的资源更少。线程是程序的执行流程，是CPU调度执行的基本单位，线程由自己的程序计数器、寄存器、堆栈和帧。同一进程中的线程拥有共同的地址空间，同时共享该进程的内存和其它资源。

在 java 编程中，并发编程主要和线程相关。在单 CPU 的情况下，一个时刻只能运行一个进程；进程在运行时，一个时刻也只能运行一个线程。进程是正在执行的程序，一个或更多的线程构成一个进程，操作系统以进程为单位运行，进程以线程为单位运行，一个进程至少包含一个主线程。

进程和线程的区别总结：

- 每个进程都有自己独立的一套变量，一个进程可以有多个线程。
- 线程是进程中执行的一个任务，一个进程中的多个线程共享数据。
- 线程间的共享数据，使得线程间的通信比进程间的通信更有效、更容易。
- 线程比进程更轻量级，创建和销毁线程的开销比进程要小得多；而进程则利于资源的管理和保护。

在 Java 中线程由 `Thread` 类表示，使用 `Thread` 有两种基本策略：

- 直接操作线程的创建、管理，在需要运行异步任务时实例化 Thread；
- 将线程管理和任务分离开，将任务交给 Executor，这部分是高级 API 部分。
