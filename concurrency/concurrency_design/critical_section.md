# 临界区

2023-06-13
***
## 简介

在并发编程中，对共享资源的并行访问可能导致意外或错误的行为，因此需要对访问共享资源的代码进行保护，以避免并行访问，被保护的部分就是**临界区**（critical section 或 critical region）。

临界区一次只允许一个 task 进入其中执行代码。临界区一般包含对共享资源的访问，如数据结构、外围设备或网络连接等，这类共享资源在并行访问时无法正常执行。

例如，不同线程可能包含对相同变量或资源的读写操作，此时最终的执行结果依赖于线程执行的顺序。例如，假设线程 A 读取变量 `x`，同时线程 B 对 `x` 进行写操作，那么线程 A 可能得到 `x` 的原始值，也可能得到新值。如下图所示：

![critical section|300](2020-03-09-21-38-38.png)

- 线程 A

```java
.
b = x + 5;               // 在时间 Tx 执行
.
```

- 线程 B

```java
.
x = 3 + z;               // 在时间 Tx 执行
.
```

对这种情况，临界区十分重要。如果希望 A 获得  `x` 的新值，线程 A 和 B 同时执行无法保证这一点。为了实现该目的，需要用临界区将变量 `x` 保护起来。首先，线程 B 访问临界区，写入值，然后 A 进去临界区，获得 `x` 的新值。

通过仔细控制在临界区中修改的变量，可以防止对共享变量的并发访问。

## 临界区的实现

在不同 OS 中临界区的实现有所不同。

临界区通常会在有限的时间内终止，线程、任务或进程等待固定时间后进入。为了保证对临界区的独占访问，在进入和离开临界区时需要**同步机制**。

所以，临界区其实就是一段需要互斥访问的代码。下图是使用锁实现的临界区，当线程需要使用共享资源，先获取资源锁，锁定资源后，其它线程无法访问，要等前一个线程释放锁离开临界区，才能轮流进入。锁等其同步机制能防止多线程同时访问共享资源。

![locks and critical section in multiple threads|450](2020-03-09-21-44-53.png)

实现临界区的最简单方式是信号量。在单处理器系统中实现临界区的方法：

- 进入临界区时禁用中断
- 在临界区避免导致上下文切换的系统调用
- 退出临界区时如遇到中断，恢复到之前的状态

在该实现，进入临界区的线程将阻止其它线程（包括中断）获取 CPU 时间，因此其它线程也无法进入其它临界区，直到原线程离开临界区。

使用多信号量可以改进这种蛮力方法。线程必须先获得信号量才能进入临界区，在离开时释放信号量。这样可以防止其它线程和原线程进入相同的临界区，但是可以获得 CPU 时间，也可以执行其它代码，包括进入受其它信号量保护的其它临界区。而且，信号量锁还有时间限制，以防止死锁。

## 参考

- [wikipedia](https://en.wikipedia.org/wiki/Critical_section)
